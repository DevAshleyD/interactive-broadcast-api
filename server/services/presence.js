/** Imports */
import R from 'ramda';
import config from '../../config/config';
import { getEventByKey, buildEventKey } from './event';
import { getAdmin } from './admin';

/** Constants */
const interactiveStreamLimit = config.interactiveStreamLimit;

/** Local Storage */

/**
 * Number of users (fans) connected to interactive sessions
 * { connectionId => count }
 * For interactive sessions, the connectionId is the host session id.
 * */

const activeConnections = {
  interactive: new Map(),
  broadcast: new Map()
};

/** { hostSessionId => data }  */
const eventData = new Map();

/** { hostSessionId => fanUrl }  */
const EventKeysBySessionId = new Map();


/** Internal Methods */

/**
 * Update active connections to interactive session
 * @param {Map} connections {id => connection}
 */
const updateEmptySessions = (connections) => {
  Object.keys(activeConnections).forEach((type) => {
    activeConnections[type].forEach((count, connectionId) => {
      if (!connections.has(connectionId)) {
        activeConnections[type].set(connectionId, 0);
      }
    });
  });
};

/** Exports */

/** How many fans are connected to the session */
const getActiveCount = eventKey => activeConnections.interactive.get(eventKey) || 0;

const getActiveConnections = () => activeConnections;

/**
 * Returns the event data associated with a fanUrl and adminId
 * @param {String} fanUrl
 * @param {String} adminId
 * @returns {String}
 */
const getInteractiveEventData = async (fanUrl, adminId) => {
  const eventKey = buildEventKey(fanUrl, adminId);

  const getEventData = async () => {
    const event = await getEventByKey(adminId, fanUrl, 'fanUrl');
    const { otApiKey, otSecret, hls, httpSupport } = await getAdmin(event.adminId);
    const data = R.merge({ otApiKey, otSecret, hls, httpSupport }, event);
    eventData.set(eventKey, data);
    return data;
  };

  return eventData.has(eventKey) ? eventData.get(eventKey) : await getEventData();
};

/**
 *
 * @param {String} sessionId - The room
 * @returns {Boolean}
 */
const ableToJoinInteractiveByEventKey = eventKey => getActiveCount(eventKey) < interactiveStreamLimit;
/**
 *
 * @param {String} fanUrl - The url for the show the fan is trying to join
 * @param {String} adminId - The adminId
 * @param {String} [token] - The token generated by 'moveUsersToInteractive' which ensures access to the interactive session
 * @returns {Promise} <Resolve => {Boolean}, Reject => {Error}>
 */
const ableToJoinInteractive = async (fanUrl, adminId) => {
  const data = await getInteractiveEventData(fanUrl, adminId);
  const ableToJoin = ableToJoinInteractiveByEventKey(buildEventKey(fanUrl, adminId));
  return {
    ableToJoin,
    eventData: data
  };
};

/**
 * Update active connections to interactive session
 * @param {Map} connections {id => connection}
 */
const updateConnections = (connections) => {
  /**
   * Socket.io automatically deletes rooms without any active connections,
   * meaning we won't receieve any data for those rooms (i.e. sessions). So
   * we need to maually set those counts to 0.
   * */
  updateEmptySessions(connections);

  connections.forEach((connection) => {
    // Update connection count
    activeConnections[connection.type].set(connection.id, connection.connections);
  });
};

/**
 * Clean up local storage
 * @param {String} sessionId - The broadcast session id
 */
const removeLocalStorage = (sessionId) => {
  const eventKey = EventKeysBySessionId.get(sessionId);
  // Remove eventData
  eventData.delete(eventKey);
  EventKeysBySessionId.delete(sessionId);
  activeConnections.interactive.delete(sessionId);
};

const setEventData = (data) => {
  if (!eventData.has(data.eventKey)) {
    eventData.set(data.eventKey, data);
    EventKeysBySessionId.set(data.sessionId, data.eventKey);
  }
  return eventData.get(data.eventKey);
};

export default {
  setEventData,
  ableToJoinInteractiveByEventKey,
  getActiveCount,
  ableToJoinInteractive,
  updateConnections,
  removeLocalStorage,
  getActiveConnections,
  getInteractiveEventData
};
